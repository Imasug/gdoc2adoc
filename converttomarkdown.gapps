/*
Usage: 
  Adding this script to your doc: 
    - Tools > Script Manager > New
    - Select "Blank Project", then paste this code in and save.
  Running the script:
    - Tools > Script Manager
    - Select "ConvertToMarkdown" function.
    - Click Run button.
    - Converted doc will be mailed to you. Subject will be "[MARKDOWN_MAKER]...".
*/

// Open handler to add Menu
function onOpen() {
  var ui = DocumentApp.getUi();
  ui.createMenu('Export')
      .addItem('Markdown file', 'ConvertToMarkdownFile')
      .addItem('Markdown email', 'ConvertToMarkdownEmail')
      .addItem('Latex equation', 'ConvertEquation')
      .addToUi();
  
  DocumentApp.getActiveDocument().add
}

function ConvertEquation() {
  var element = DocumentApp.getActiveDocument().getCursor().getElement();
  
  // Scan upwards for an equation
  while(element.getType() != DocumentApp.ElementType.EQUATION) {
    if(element.getParent() == null)
      break;
    
    element = element.getParent();  
  }
  
  if(element.getType() != DocumentApp.ElementType.EQUATION) {
    DocumentApp.getUi().alert("Put cursor into an equation element!"); 
    return; 
  }
  
  // Covert equation
  var latexEquation = handleEquationFunction(element); 
  var latexEquationText = "$" + latexEquation.trim() + "$"; 
  
  // Show results
  DocumentApp.getUi().alert(latexEquationText);
}

// Convert current document to markdown and email it 
function ConvertToMarkdownEmail() {
  // Convert to markdown
  var convertedDoc = ConvertToMarkdown(); 
  
  // Add markdown document to attachments
  convertedDoc.attachments.push({"fileName":DocumentApp.getActiveDocument().getName()+".md", 
                                 "mimeType": "text/plain", "content": convertedDoc.text});
  
  
  // Send email with markdown document
  MailApp.sendEmail(Session.getActiveUser().getEmail(),
					"[MARKDOWN_MAKER] "+DocumentApp.getActiveDocument().getName(),
					"Your converted markdown document is attached (converted from "+DocumentApp.getActiveDocument().getUrl()+")"+
					"\n\nDon't know how to use the format options? See http://github.com/mangini/gdocs2md\n",
					{ "attachments": convertedDoc.attachments });
}

// Convert current document to file and save it to GDrive
function ConvertToMarkdownFile() {
  // Convert to markdwon
  var convertedDoc = markdown(); 
  
  // Create folder
  var id = DocumentApp.getActiveDocument().getId();
  var file = DocsList.getFileById(id);
  var parents = file.getParents();
  
  if(parents.length > 1)
  {
    Logger.log("File has multiple parent directory. Script does not work in this case"); 
    return null; 
  }
  
  // Use first parent
  var parent = parents[0];
  
  // Check if target folder exists  
  for(var folder in parent.getFolders()) {
    folder = parent.getFolders()[folder]; 
    
    if(folder.getName() == 'target') {
      Logger.log("Trashing target folder..."); 
      folder.setTrashed(true); 
      break; 
    }
  }
  
  // Create new target folder if none exists
  Logger.log("Creating output folder..."); 
  var found = parent.createFolder("target"); 
  
  // Write all files to target folder
  for(var file in convertedDoc.files) {
    file = convertedDoc.files[file];
    var blob = file.blob.copyBlob();
    var name = file.name; 
    blob.setName(name); 
    found.createFile(blob); 
  }
  
  // Write mardown file to target folder
  found.createFile(DocumentApp.getActiveDocument().getName() + ".md", convertedDoc.text, "text/plain");   
}

function markdown() {
  var doc = DocumentApp.getActiveDocument().getActiveSection();
  
  var state = {
    'inSource' : false,
    'images' : [],
    'imageCounter' : 0,
    'prevDoc' : [],
    'nextDoc' : [],
  };
  var textElements = processDocument(doc, state, 0);
  var text = textElements.join('');
  
  // Replace critical chars
  text = text.replace('\u201d', '"').replace('\u201c', '"');
  
  // Debug logging
  Logger.log("Result: " + text);
  Logger.log("Images: " + state.imageCounter);
  
  // Build attachment and file lists
  var attachments = [];
  var files = [];
  for(var i in state.images) {
    var image = state.images[i];
    attachments.push( {
      "fileName": image.name,
      "mimeType": image.type,
      "content": image.bytes
    } );
    
    files.push( {
      "name" : image.name,
      "blob" : image.blob
    });
  }
  
  // Results
  return {
    'files' : files,
    'attachments' : attachments,
    'text' : text,
  };
}

// Covert current document to markdown
function ConvertToMarkdown() {
  var numChildren = DocumentApp.getActiveDocument().getActiveSection().getNumChildren();
  var text = "";
  var inSrc = false;
  var inClass = false;
  var globalImageCounter = 0;
  var globalListCounters = {};
  
  // edbacher: added a variable for indent in src <pre> block. Let style sheet do margin.
  var srcIndent = "";
  
  var attachments = [];
  var files = []; 
  
  // Walk through all the child elements of the doc.
  for (var i = 0; i < numChildren; i++) {
    var child = DocumentApp.getActiveDocument().getActiveSection().getChild(i);
    var result = processParagraph(i, child, inSrc, globalImageCounter, globalListCounters);
    globalImageCounter += (result && result.images) ? result.images.length : 0;
    if (result!==null) {
      if (result.sourcePretty==="start" && !inSrc) {
        inSrc=true;
        text+="<pre class=\"prettyprint\">\n";
      } else if (result.sourcePretty==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.source==="start" && !inSrc) {
        inSrc=true;
        text+="<pre>\n";
      } else if (result.source==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.inClass==="start" && !inClass) {
        inClass=true;
        text+="<div class=\""+result.className+"\">\n";
      } else if (result.inClass==="end" && inClass) {
        inClass=false;
        text+="</div>\n\n";
      } else if (inClass) {
        text+=result.text+"\n\n";
      } else if (inSrc) {
        text+=(srcIndent+escapeHTML(result.text)+"\n");
      } else if(result.text && result.text.length>0 && result.singleLb) {
        text+=result.text+"\n";
      } else if (result.text && result.text.length>0) {
        text+=result.text+"\n\n";
      }
      
      
      if (result.images && result.images.length>0) {
        for (var j=0; j<result.images.length; j++) {
          attachments.push( {
            "fileName": result.images[j].name,
            "mimeType": result.images[j].type,
            "content": result.images[j].bytes
          } );
          
          files.push( {
            "name" : result.images[j].name,
            "blob" : result.images[j].blob
          });
        }
      }
    } else if (inSrc) { // support empty lines inside source code
      text+='\n';
    }
      
  }
  
  // Debug logging
  Logger.log(text);
  
  return {
    'files' : files,
    'attachments' : attachments,
    'text' : text
  }; 
}

function escapeHTML(text) {
  return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function processTable(element) {
  var textElements = [];
  
  String.prototype.repeat = function( num )
  {
    return new Array( num + 1 ).join( this );
  }
  
  textElements.push("\n");
  
  function buildTable(size) {
    var stack = []
    var maxSize = 0; 
    
    for(var ir=0; ir<element.getNumRows(); ir++) {
      var row = element.getRow(ir);
      
      // Add header seperator
      if(ir == 1) {
        for(var ic=0; ic<row.getNumCells(); ic++) {
          stack.push("|-" + "-".repeat(size));
        }
        stack.push("-|\n");
      }
      
      // Add table data
      for(var ic=0; ic<row.getNumCells(); ic++) {
        var cell = row.getCell(ic);
        var text = cell.getText(); 
        text = text.replace(/(\r\n|\n|\r)/gm,"");
        maxSize = Math.max(text.length, maxSize); 
        
        if(size > text.length) {
          text += " ".repeat(size - text.length)
        }
        
        stack.push("| " + text);
      }
      
      stack.push(" |\n");
    }
    
    stack.push("\n");
    return {
      maxSize : maxSize,
      stack : stack,
    };
  }
  
  var table = buildTable(100); 
  table = buildTable(Math.max(10, table.maxSize + 1)); 
  textElements = textElements.concat(table.stack);
  
  textElements.push("\n");
  return textElements;
}


function handleText(doc, state) {
  var formatted = doc.getText(); 
  var lastIndex = formatted.length; 
  var attrs = doc.getTextAttributeIndices();
  
  // Iterate backwards through all attributes
  for(var i=attrs.length-1; i >= 0; i--) {
    // Current position in text
    var index = attrs[i];
        
    // Handle links
    if(doc.getLinkUrl(index)) {
      var url = doc.getLinkUrl(index);
      if (i > 0 && attrs[i-1] == index - 1 && doc.getLinkUrl(attrs[i-1]) === url) {
        i -= 1;
        index = attrs[i];
        url = txt.getLinkUrl(off);
      }
      formatted = formatted.substring(0, index) + '[' + formatted.substring(index, lastIndex) + '](' + url + ')' + formatted.substring(lastIndex);
    } 
    
    // Handle font family
    if(doc.getFontFamily(index)) {
      var font = doc.getFontFamily(index); 
      var sourceFont = font.COURIER_NEW; 
      
      if (!state.inSource && font === sourceFont) {
        // Scan left until text without source font is found
        while (i > 0 && txt.getFontFamily(attrs[i-1]) && txt.getFontFamily(attrs[i-1]) === sourceFont) {
          i -= 1;
          off = attrs[i];
        }
        
        formatted = formatted.substring(0, lastIndex) + '`' + formatted.substring(index, lastIndex) + '`' + formatted.substring(lastIndex);
      }
    }
    
    // Handle bold and bold italic
    if(doc.isBold(index)) {
      var dleft, right;
      dleft = dright = "**";
      if (doc.isItalic(index)) 
      {
        // edbacher: changed this to handle bold italic properly.
        dleft = "**_"; 
        dright  = "_**";
      }
      formatted = formatted.substring(0, index) + dleft + formatted.substring(index, lastIndex) + dright + formatted.substring(lastIndex);
      
    } 
    // Handle italic
    else if(doc.isItalic(index)) {
      formatted = formatted.substring(0, index) + '*' + formatted.substring(index, lastIndex) + '*' + formatted.substring(lastIndex);
    }
    
    // Keep track of last position in text
    lastIndex = index; 
  }
  
  var textElements = [formatted]; 
  return textElements; 
}



function handleListItem(item, state, depth) {
  var textElements = [];
  
  // Prefix
  var prefix = '';
  
  // Add nesting level
  for (var i=0; i<item.getNestingLevel(); i++) {
    prefix += '  ';
  }
  
  // Add marker based on glyph type
  var glyph = item.getGlyphType();
  switch(glyph) {
    case DocumentApp.GlyphType.BULLET:
    case DocumentApp.GlyphType.HOLLOW_BULLET:
    case DocumentApp.GlyphType.SQUARE_BULLET: 
      prefix += '* ';
      break; 
    default:
      var key = item.getListId() + '.' + item.getNestingLevel();
      var counter = state.listCounters[key] || 0;
      counter++;
      state.listCounters[key] = counter;
      prefix += counter + '. ';
  }
  
  // Add prefix
  textElements.push(prefix);
  
  // Handle all childs
  textElements = textElements.concat(processChilds(item, state, depth));
  
  return textElements;
}

function handleImage(image, state) {
  // Determine file extension based on content type
  var contentType = image.getBlob().getContentType();
  var fileExtension = '';
  if (/\/png$/.test(contentType)) {
    fileExtension = ".png";
  } else if (/\/gif$/.test(contentType)) {
    fileExtension = ".gif";
  } else if (/\/jpe?g$/.test(contentType)) {
    fileExtension = ".jpg";
  } else {
    throw "Unsupported image type: " + contentType;
  }

  // Create filename
  var filename = 'img_' + state.imageCounter + fileExtension;
  state.imageCounter++;
  
  // Add image
  var textElements = []
  textElements.push('![image alt text](' + filename + ')');
  state.images.push( {
    "bytes": image.getBlob().getBytes(), 
    "blob": image.getBlob(), 
    "type": contentType, 
    "name": filename,
  });
  
  return textElements;
}

function processChilds(doc, state, depth) {
  var textElements = []
  for(var i=0; i < doc.getNumChildren(); i++)  {
    var child = doc.getChild(i); 
    state.nextDoc[depth] = (i+1 < doc.getNumChildren())?doc.getChild(i+1) : child;
    textElements = textElements.concat(processDocument(child, state, depth+1)); 
  }
  return textElements;
}

function processDocument(doc, state, depth) {
  //Logger.log("Processing document: " + doc); 
  //Logger.log("State: " + state); 
  
  var prevDoc = state.prevDoc[depth] || doc; 
  state.prevDoc[depth] = doc; 
  
  // Result
  var textElements = [];
    
  switch(doc.getType()) {
    case DocumentApp.ElementType.BODY_SECTION: 
      textElements = textElements.concat(processChilds(doc, state, depth));
      break; 
      
    case DocumentApp.ElementType.PARAGRAPH:
      // Determine header prefix
      var prefix = ''; 
      switch (doc.getHeading()) {
        // Add a # for each heading level. No break, so we accumulate the right number.
        case DocumentApp.ParagraphHeading.HEADING6: prefix += '#';
        case DocumentApp.ParagraphHeading.HEADING5: prefix += '#';
        case DocumentApp.ParagraphHeading.HEADING4: prefix += '#';
        case DocumentApp.ParagraphHeading.HEADING3: prefix += '#';
        case DocumentApp.ParagraphHeading.HEADING2: prefix += '#';
        case DocumentApp.ParagraphHeading.HEADING1: prefix += '#';
      }
      
      // Add space
      if(prefix.length > 0)
        prefix += ' ';
      
      // Push prefix
      textElements.push(prefix);
      
      // Process childs
      textElements = textElements.concat(processChilds(doc, state, depth));
      
      // Add paragraph break
      textElements.push('\n\n');
      break; 
      
    case DocumentApp.ElementType.LIST_ITEM:
      textElements = textElements.concat(handleListItem(doc, state, depth)); 
      textElements.push('\n');
      
      if(state.nextDoc[depth-1].getType() != doc.getType()) {
        textElements.push('\n');
      }
      
      break;
      
    case DocumentApp.ElementType.HORIZONTAL_RULE:
      textElements.push('* * *\n');
      break; 
     
    case DocumentApp.ElementType.FOOTNOTE:
      textElements.push(' (NOTE: ' + doc.getText() + ')');
      break;
      
    case DocumentApp.ElementType.TABLE:
      textElements = textElements.concat(processTable(doc));
      break;
      
    case DocumentApp.ElementType.TABLE_OF_CONTENTS:
      textElements.push('[[TOC]]');
      break;
      
    case DocumentApp.ElementType.TEXT:
      var text = handleText(doc, state);
      textElements = textElements.concat(text);
      break;
      
    case DocumentApp.ElementType.INLINE_IMAGE: 
      textElements = textElements.concat(handleImage(doc, state));
      break; 
      
    case DocumentApp.ElementType.EQUATION: 
      var latexEquation = handleEquationFunction(doc, state); 
      latexEquation = "$$" + latexEquation.trim() + "$$"; 
      textElements.push(latexEquation);
      break; 
    default:
      throw("Unknown element type: " + doc.getType());
  }
  
  return textElements; 
}

// Process each child element (not just paragraphs).
function processParagraph(index, element, inSrc, imageCounter, listCounters) {
  // First, check for things that require no processing.
  if (element.getNumChildren()==0) {
    return null;
  }  
  
  // Punt on TOC.
  if (element.getType() === DocumentApp.ElementType.TABLE_OF_CONTENTS) {
    return {"text": "[[TOC]]"};
  }
  
  // Set up for real results.
  var result = {
    'singleLb' : false,
  };
  var pOut = "";
  var textElements = [];
  var imagePrefix = "image_";
    
  // Handle tables
  if (element.getType() === DocumentApp.ElementType.TABLE) {
    textElements = processTable(element, textElements);
  }
    
  // Process various types (ElementType).
  for (var i = 0; i < element.getNumChildren(); i++) {
    var t=element.getChild(i).getType();
    
    if (t === DocumentApp.ElementType.TABLE_ROW) {
      // do nothing: already handled TABLE_ROW
    } else if (t === DocumentApp.ElementType.TEXT) {
      var txt=element.getChild(i);
      pOut += txt.getText();
      textElements.push(txt);
    } else if (t === DocumentApp.ElementType.INLINE_IMAGE) {
      result.images = result.images || [];
      var contentType = element.getChild(i).getBlob().getContentType();
      var extension = "";
      if (/\/png$/.test(contentType)) {
        extension = ".png";
      } else if (/\/gif$/.test(contentType)) {
        extension = ".gif";
      } else if (/\/jpe?g$/.test(contentType)) {
        extension = ".jpg";
      } else {
        throw "Unsupported image type: "+contentType;
      }
      var name = imagePrefix + imageCounter + extension;
      imageCounter++;
      textElements.push('![image alt text]('+name+')');
      result.images.push( {
        "bytes": element.getChild(i).getBlob().getBytes(), 
        "blob": element.getChild(i).getBlob(), 
        "type": contentType, 
        "name": name});
    } else if (t === DocumentApp.ElementType.PAGE_BREAK) {
      // ignore
    } else if (t === DocumentApp.ElementType.HORIZONTAL_RULE) {
      textElements.push('* * *\n');
    } else if (t === DocumentApp.ElementType.FOOTNOTE) {
      textElements.push(' (NOTE: '+element.getChild(i).getFootnoteContents().getText()+')');
    } else if (t == DocumentApp.ElementType.EQUATION) {
      // Convert equation to Latex equation string
      var equation = element.getChild(i); 
      var latexEquation = handleEquationFunction(equation); 

      // Add equation marker
      latexEquation = "$$" + latexEquation.trim() + "$$"; 
            
      // Put equation onto stack
      textElements.push(latexEquation);
      
    } else {
      throw "Paragraph "+index+" of type "+element.getType()+" has an unsupported child: "
      +t+" "+(element.getChild(i)["getText"] ? element.getChild(i).getText():'')+" index="+index;
    }
  }

  if (textElements.length==0) {
    // Isn't result empty now?
    return result;
  }
  
  // evb: Add source pretty too. (And abbreviations: src and srcp.)
  // process source code block:
  if (/^\s*---\s+srcp\s*$/.test(pOut) || /^\s*---\s+source pretty\s*$/.test(pOut)) {
    result.sourcePretty = "start";
  } else if (/^\s*---\s+src\s*$/.test(pOut) || /^\s*---\s+source code\s*$/.test(pOut)) {
    result.source = "start";
  } else if (/^\s*---\s+class\s+([^ ]+)\s*$/.test(pOut)) {
    result.inClass = "start";
    result.className = RegExp.$1;
  } else if (/^\s*---\s*$/.test(pOut)) {
    result.source = "end";
    result.sourcePretty = "end";
    result.inClass = "end";
  } else if (/^\s*---\s+jsperf\s*([^ ]+)\s*$/.test(pOut)) {
    result.text = '<iframe style="width: 100%; height: 340px; overflow: hidden; border: 0;" '+
                  'src="http://www.html5rocks.com/static/jsperfview/embed.html?id='+RegExp.$1+
                  '"></iframe>';
  } else {
    // Prefix for headlines and lists
    prefix = findPrefix(index, inSrc, element, listCounters);
    var singleLb = prefix.singleLb;
    prefix = prefix.prefix;
  
    Logger.log("single lb: " + singleLb); 
    result.singleLb = singleLb;
    
    // Join all text elements and add formatting
    var pOut = "";
    for (var i=0; i<textElements.length; i++) {
      pOut += processTextElement(inSrc, textElements[i]);
    }

    // replace Unicode quotation marks
    pOut = pOut.replace('\u201d', '"').replace('\u201c', '"');
 
    result.text = prefix+pOut;
  }
  
  return result;
}
















// Escape chars with a special meaning in Latex
function latexSanitize(text) {
  text = text.replace("\\", "\\\\"); 
  text = text.replace("%", "\\%");
  return text; 
}

// Converte an Equation or Function element to a Latex expression
function handleEquationFunction(func, state) {
  //Logger.log("Equation converter handling: " + func.getType());
  var equation =  ""; 
  
  for(var i=0; i<func.getNumChildren(); i++) {
    var child = func.getChild(i); 
    
    if(child.getType() == DocumentApp.ElementType.EQUATION_FUNCTION) {
      equation += child.getCode() + "{" + handleEquationFunction(child, state); 
    }
    else if(child.getType() == DocumentApp.ElementType.EQUATION_FUNCTION_ARGUMENT_SEPARATOR) {
      equation = equation.trim() + "}{"; 
    }
    else if(child.getType() == DocumentApp.ElementType.EQUATION_SYMBOL) {
      equation += child.getCode() + " "; 
    }
    else if(child.getType() == DocumentApp.ElementType.TEXT) {
      equation += latexSanitize(child.getText()) + " "; 
    }
  }
  
  if(func.getType() == DocumentApp.ElementType.EQUATION_FUNCTION)
    equation = equation.trim() + "}";
  
  //Logger.log("Equation converter result: " + equation);
  return equation;
}

// Add correct prefix to list items.
function findPrefix(index, inSrc, element, listCounters) {
  var prefix="";
  var singleLineBreak = false; 
  if (!inSrc) {
    if (element.getType()===DocumentApp.ElementType.PARAGRAPH) {
      var paragraphObj = element;
      switch (paragraphObj.getHeading()) {
        // Add a # for each heading level. No break, so we accumulate the right number.
        case DocumentApp.ParagraphHeading.HEADING6: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING5: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING4: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING3: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING2: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING1: prefix+="# ";
        default:
      }
    } else if (element.getType()===DocumentApp.ElementType.LIST_ITEM) {
      var listItem = element;
      var nesting = listItem.getNestingLevel()
      for (var i=0; i<nesting; i++) {
        prefix += "  ";
      }
      var gt = listItem.getGlyphType();
      // Bullet list (<ul>):
      if (gt === DocumentApp.GlyphType.BULLET
          || gt === DocumentApp.GlyphType.HOLLOW_BULLET
          || gt === DocumentApp.GlyphType.SQUARE_BULLET) {
        prefix += "* ";
      } else {
        // Ordered list (<ol>):
        var key = listItem.getListId() + '.' + listItem.getNestingLevel();
        var counter = listCounters[key] || 0;
        counter++;
        listCounters[key] = counter;
        prefix += counter+". ";
      }
      
      // Check if this item is followed by another list item
      var num = DocumentApp.getActiveDocument().getActiveSection().getNumChildren();
      if(index + 1 < num) {
        var next = DocumentApp.getActiveDocument().getActiveSection().getChild(index + 1);
        if(next.getType() == DocumentApp.ElementType.LIST_ITEM) {
          singleLineBreak = true; 
        }
      }
      
    }
  }
  
  return {
    'prefix' : prefix,
    'singleLb' : singleLineBreak
  };
}

function processTextElement(inSrc, txt) {
  if (typeof(txt) === 'string') {
    return txt;
  }
  
  var pOut = txt.getText();
  if (! txt.getTextAttributeIndices) {
    return pOut;
  }
  
  var attrs=txt.getTextAttributeIndices();
  var lastOff=pOut.length;

  for (var i=attrs.length-1; i>=0; i--) {
    var off=attrs[i];
    var url=txt.getLinkUrl(off);
    var font=txt.getFontFamily(off);
    if (url) {  // start of link
      if (i>=1 && attrs[i-1]==off-1 && txt.getLinkUrl(attrs[i-1])===url) {
        // detect links that are in multiple pieces because of errors on formatting:
        i-=1;
        off=attrs[i];
        url=txt.getLinkUrl(off);
      }
      pOut=pOut.substring(0, off)+'['+pOut.substring(off, lastOff)+']('+url+')'+pOut.substring(lastOff);
    } else if (font) {
      if (!inSrc && font===font.COURIER_NEW) {
        while (i>=1 && txt.getFontFamily(attrs[i-1]) && txt.getFontFamily(attrs[i-1])===font.COURIER_NEW) {
          // detect fonts that are in multiple pieces because of errors on formatting:
          i-=1;
          off=attrs[i];
        }
        pOut=pOut.substring(0, off)+'`'+pOut.substring(off, lastOff)+'`'+pOut.substring(lastOff);
      }
    }
    if (txt.isBold(off)) {
      var d1 = d2 = "**";
      if (txt.isItalic(off)) {
        // edbacher: changed this to handle bold italic properly.
        d1 = "**_"; d2 = "_**";
      }
      pOut=pOut.substring(0, off)+d1+pOut.substring(off, lastOff)+d2+pOut.substring(lastOff);
    } else if (txt.isItalic(off)) {
      pOut=pOut.substring(0, off)+'*'+pOut.substring(off, lastOff)+'*'+pOut.substring(lastOff);
    }
    lastOff=off;
  }
  return pOut;
}